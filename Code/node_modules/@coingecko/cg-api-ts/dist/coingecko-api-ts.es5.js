/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

var RootAPI;
(function (RootAPI) {
    RootAPI["PROD"] = "https://api.coingecko.com/api/v3";
    RootAPI["DEV"] = "http://localhost:3010";
})(RootAPI || (RootAPI = {}));
var APIError;
(function (APIError) {
    APIError["DOWN"] = "DOWN";
    APIError["SERVER"] = "SERVER";
    APIError["TIMEOUT"] = "TIMEOUT";
    APIError["UNAUTHORIZED"] = "UNAUTHORIZED";
})(APIError || (APIError = {}));

// ENUM
var SortOrder;
(function (SortOrder) {
    SortOrder["NAME_ASCENDING"] = "coin_name_asc";
    SortOrder["NAME_DESCENDING"] = "coin_name_desc";
    SortOrder["PRICE_ASCENDING"] = "price_asc";
    SortOrder["PRICE_DESCENDING"] = "price_desc";
    SortOrder["PRICE_CHANGE_ASCENDING"] = "h24_change_asc";
    SortOrder["PRICE_CHANGE_DESCENDING"] = "h24_change_desc";
    SortOrder["PRICE_CHANGE_1H_ASCENDING"] = "price_change_1h_asc";
    SortOrder["PRICE_CHANGE_1H_DESCENDING"] = "price_change_1h_desc";
    SortOrder["PRICE_CHANGE_7D_ASCENDING"] = "price_change_7d_asc";
    SortOrder["PRICE_CHANGE_7D_DESCENDING"] = "price_change_7d_desc";
    SortOrder["MARKET_CAP_ASCENDING"] = "market_cap_asc";
    SortOrder["MARKET_CAP_DESCENDING"] = "market_cap_desc";
    SortOrder["VOLUME_DESC"] = "volume_desc";
    SortOrder["VOLUME_ASC"] = "volume_asc";
    SortOrder["RECENTLY_ADDED_DESC"] = "recently_added_desc";
})(SortOrder || (SortOrder = {}));
var CoinsMarketsSortOrder;
(function (CoinsMarketsSortOrder) {
    CoinsMarketsSortOrder["MARKET_CAP_DESC"] = "market_cap_desc";
    CoinsMarketsSortOrder["MARKET_CAP_ASC"] = "market_cap_asc";
    CoinsMarketsSortOrder["VOLUME_ASC"] = "volume_asc";
    CoinsMarketsSortOrder["VOLUME_DESC"] = "volume_desc";
})(CoinsMarketsSortOrder || (CoinsMarketsSortOrder = {}));
var TickerSortOrder;
(function (TickerSortOrder) {
    TickerSortOrder["TRUST_SCORE_DESC"] = "trust_score_desc";
    TickerSortOrder["TRUST_SCORE_ASC"] = "trust_score_asc";
    TickerSortOrder["VOLUME_DESC"] = "volume_desc";
    TickerSortOrder["VOLUME_ASC"] = "volume_asc";
})(TickerSortOrder || (TickerSortOrder = {}));
var PriceChangePercentage;
(function (PriceChangePercentage) {
    PriceChangePercentage["1h"] = "1h";
    PriceChangePercentage["24h"] = "24h";
    PriceChangePercentage["7d"] = "7d";
    PriceChangePercentage["14d"] = "14d";
    PriceChangePercentage["30d"] = "30d";
    PriceChangePercentage["200d"] = "200d";
    PriceChangePercentage["1y"] = "1y";
})(PriceChangePercentage || (PriceChangePercentage = {}));
// BEAM
var BeamFilterCategories;
(function (BeamFilterCategories) {
    BeamFilterCategories["ALL_CATEGORIES"] = "";
    BeamFilterCategories["GENERAL"] = "general";
    BeamFilterCategories["MILESTONE"] = "milestone";
    BeamFilterCategories["PARTNERSHIP"] = "partnership";
    BeamFilterCategories["FUND_MOVEMENT"] = "fund_movement";
    BeamFilterCategories["EXCHANGE_LISTINGS"] = "exchange_listing";
    BeamFilterCategories["SOFTWARE_RELEASE"] = "software_release";
    BeamFilterCategories["NEW_LISTINGS"] = "new_listings";
    BeamFilterCategories["EVENT"] = "event";
})(BeamFilterCategories || (BeamFilterCategories = {}));
var BeamFilterProjectType;
(function (BeamFilterProjectType) {
    BeamFilterProjectType["COIN"] = "coin";
    BeamFilterProjectType["MARKET"] = "market";
    BeamFilterProjectType["ALL"] = "";
})(BeamFilterProjectType || (BeamFilterProjectType = {}));
var ChartPeriodControlOption;
(function (ChartPeriodControlOption) {
    ChartPeriodControlOption["Option1Hour"] = "1H";
    ChartPeriodControlOption["Option24Hour"] = "24H";
    ChartPeriodControlOption["Option7Day"] = "7D";
    ChartPeriodControlOption["Option14Day"] = "14D";
    ChartPeriodControlOption["Option30Day"] = "30D";
    ChartPeriodControlOption["Option60Day"] = "60D";
    ChartPeriodControlOption["Option90Day"] = "90D";
    ChartPeriodControlOption["Option1Year"] = "1Y";
    ChartPeriodControlOption["OptionMax"] = "MAX";
})(ChartPeriodControlOption || (ChartPeriodControlOption = {}));
var TrustScore;
(function (TrustScore) {
    TrustScore["Green"] = "green";
    TrustScore["Yellow"] = "yellow";
    TrustScore["Red"] = "red";
    TrustScore["Gray"] = "gray";
})(TrustScore || (TrustScore = {}));
var DerivativesContractType;
(function (DerivativesContractType) {
    DerivativesContractType["Perpetual"] = "perpetual";
    DerivativesContractType["Futures"] = "futures";
})(DerivativesContractType || (DerivativesContractType = {}));
var DerivativesExchangesSortType;
(function (DerivativesExchangesSortType) {
    DerivativesExchangesSortType["NAME_ASC"] = "name_asc";
    DerivativesExchangesSortType["NAME_DESC"] = "name_desc";
    DerivativesExchangesSortType["OPEN_INTEREST_BTC_ASC"] = "open_interest_btc_asc";
    DerivativesExchangesSortType["OPEN_INTEREST_BTC_DESC"] = "open_interest_btc_desc";
    DerivativesExchangesSortType["TRADE_VOLUME_BTC_ASC"] = "trade_volume_24h_btc_asc";
    DerivativesExchangesSortType["TRADE_VOLUME_BTC_DESC"] = "trade_volume_24h_btc_desc";
})(DerivativesExchangesSortType || (DerivativesExchangesSortType = {}));
var DerivativesExchangeTickerType;
(function (DerivativesExchangeTickerType) {
    DerivativesExchangeTickerType["NONE"] = "";
    DerivativesExchangeTickerType["UNEXPIRED"] = "unexpired";
    DerivativesExchangeTickerType["ALL"] = "all";
})(DerivativesExchangeTickerType || (DerivativesExchangeTickerType = {}));

class CGError extends Error {
    constructor(type, response, ...params) {
        // Pass remaining arguments (including vendor specific ones) to parent constructor
        super(...params);
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, CGError);
        }
        this.name = "CoinGeckoAPIError";
        // Custom debugging information
        this.type = type;
        this.response = response || null;
    }
}

/**
 * urlEncode: Encode URL functions by passing in params
 */
const urlEncode = (params) => {
    return Object.keys(params)
        .map((key) => {
        return encodeURIComponent(key) + "=" + encodeURIComponent(params[key]);
    })
        .join("&");
};
/**
 * Timeout Wrapper, timeout a Promise after certain amount of time
 */
const timeoutWrapper = (ms, promise) => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            reject(new CGError(APIError.TIMEOUT, null, `Request timeout after ${ms}ms`));
        }, ms);
        promise.then(resolve, reject);
    });
};
/**
 * handleError, Handle Error in the app
 */
const handleError = (response) => {
    if (response.status >= 500 && response.status <= 530) {
        throw new CGError(APIError.DOWN, response, "CoinGecko API down");
    }
    else if (!response.ok && response.status === 401) {
        throw new CGError(APIError.UNAUTHORIZED, response, response.statusText);
    }
    else if (!response.ok) {
        throw new CGError(APIError.SERVER, response, response.statusText);
    }
    return response;
};

class CoinGeckoAPI {
    constructor(fetch, timeout = 20000, baseUrl = RootAPI.PROD, getHeader = {}, postHeader = {}) {
        this.fetch = fetch;
        this.timeout = timeout;
        this.baseUrl = baseUrl;
        this.getHeader = getHeader;
        this.postHeader = postHeader;
    }
    /**
     * Using Fetch to send GET request
     */
    getReq(endpoint, header = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield timeoutWrapper(this.timeout, this.fetch(`${this.baseUrl}${endpoint}`, {
                method: "GET",
                headers: Object.assign({}, this.getHeader, header),
            }));
            handleError(response);
            let data = null;
            try {
                data = yield response.json();
            }
            catch (_err) {
                return {
                    response,
                    data,
                    endpoint,
                };
            }
            return {
                response,
                data,
                endpoint,
            };
        });
    }
    /**
     * Using Fetch to send POST request
     */
    postReq(endpoint, body, header = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.fetch(`${this.baseUrl}${endpoint}`, {
                method: "POST",
                body,
                headers: Object.assign({}, this.postHeader, header),
            });
            handleError(response);
            let data = null;
            try {
                data = yield response.json();
            }
            catch (_err) {
                return {
                    response,
                    data,
                    endpoint,
                };
            }
            return {
                response,
                data,
                endpoint,
            };
        });
    }
    /**
     * Using Fetch to send DELETE request
     */
    deleteReq(endpoint, header = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield timeoutWrapper(this.timeout, this.fetch(`${this.baseUrl}${endpoint}`, {
                method: "DELETE",
                headers: Object.assign({}, this.getHeader, header),
            }));
            handleError(response);
            let data = null;
            try {
                data = yield response.json();
            }
            catch (_err) {
                return {
                    response,
                    data,
                    endpoint,
                };
            }
            return {
                response,
                data,
                endpoint,
            };
        });
    }
    /**
     * Using Fetch to send PUT request
     */
    putReq(endpoint, body, header = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.fetch(`${this.baseUrl}${endpoint}`, {
                method: "PUT",
                body,
                headers: Object.assign({}, this.postHeader, header),
            });
            handleError(response);
            let data = null;
            try {
                data = yield response.json();
            }
            catch (_err) {
                return {
                    response,
                    data,
                    endpoint,
                };
            }
            return {
                response,
                data,
                endpoint,
            };
        });
    }
    // API CALL
    /**
     * Check API server status
     * https://api.coingecko.com/api/v3/ping
     */
    getPing() {
        return __awaiter(this, void 0, void 0, function* () {
            const d = yield this.getReq("/ping");
            return Object.assign({}, d, { data: d.data.gecko_says === "(V3) To the Moon!" });
        });
    }
    /**
     * Get the current price of any cryptocurrencies in any other supported currencies that you need.
     * https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd
     */
    getSimplePrice(ids, vsCurrencies) {
        const encodedUrl = urlEncode({ ids, vs_currencies: vsCurrencies });
        return this.getReq(`/simple/price?${encodedUrl}`);
    }
    // TODO: /simple/token_price/{id} Get current price of tokens (using contract addresses) for a given platform in any other currency that you need.
    /**
     * Get list of supported_vs_currencies.
     * https://api.coingecko.com/api/v3/simple/supported_vs_currencies
     */
    getSimpleSupportedVsCurrencies() {
        return this.getReq("/simple/supported_vs_currencies");
    }
    /**
     * List all supported coins id, name and symbol (no pagination required)
     * https://api.coingecko.com/api/v3/coins/list
     */
    getCoinsList() {
        return this.getReq("/coins/list");
    }
    // GET /coins/markets List all supported coins price, market cap, volume, and market related data
    getCoinsMarket(vsCurrency, order = CoinsMarketsSortOrder.MARKET_CAP_DESC, ids = [], perPage = 100, page = 1, sparkline = false, priceChangePercentage = []) {
        if (perPage &&
            typeof perPage === "number" &&
            (perPage > 250 || perPage < 1)) {
            throw new Error("Invalid per page, it should be within 1 to 250.");
        }
        const encodedUrl = urlEncode({
            vs_currency: vsCurrency,
            order,
            ids: ids.join(","),
            per_page: perPage,
            page,
            sparkline,
            price_change_percentage: priceChangePercentage.join(","),
        });
        return this.getReq(`/coins/markets?${encodedUrl}`);
    }
    /**
     * Get current data (name, price, market, ... including exchange tickers) for a coin
     * https://api.coingecko.com/api/v3/coins/bitcoin
     */
    getCoinsId(coin, localization = true, tickers = true, marketData = true, communityData = true, developerData = true, sparkline = false, include_exchange_logo = false) {
        const encodedUrl = urlEncode({
            localization,
            tickers,
            market_data: marketData,
            community_data: communityData,
            developer_data: developerData,
            sparkline,
            include_exchange_logo,
        });
        return this.getReq(`/coins/${coin}?${encodedUrl}`);
    }
    getCoinsIdTickers(id, includeExchangeLogo = true, page = 1, order = TickerSortOrder.TRUST_SCORE_DESC, exchangesIds = []) {
        const encodedUrl = urlEncode({
            include_exchange_logo: includeExchangeLogo,
            page,
            order,
            exchanges_ids: exchangesIds.join(","),
        });
        return this.getReq(`/coins/${id}/tickers?${encodedUrl}`);
    }
    /**
     * Get market chart of a certain coin (prices, market cap and volume)
     * https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=2
     */
    getCoinsIdMarketChart(coin, vsCurrency, days) {
        const encodedUrl = urlEncode({
            vs_currency: vsCurrency,
            days,
        });
        return this.getReq(`/coins/${coin}/market_chart?${encodedUrl}`);
    }
    /**
     * Get status updates for a given coin
     * https://api.coingecko.com/api/v3/coins/dash/status_updates?page=1&per_page=2
     */
    getCoinsIdStatusUpdates(coin, page, perPage = 10) {
        const encodedUrl = urlEncode({
            per_page: perPage,
            page,
        });
        return this.getReq(`/coins/${coin}/status_updates?${encodedUrl}`);
    }
    /**
     * List all the available category list
     * https://api.coingecko.com/api/v3/coins/category_list
     * @param locale
     */
    getCoinsCategoryList(locale = "en") {
        const encodedUrl = urlEncode({
            locale,
        });
        return this.getReq(`/coins/category_list?${encodedUrl}`);
    }
    getCoinsLite(vsCurrency = "usd", categoryId = "cryptocurrency", locale = "en", page = 1, perPage = 20, order = SortOrder.MARKET_CAP_DESCENDING) {
        const encodedUrl = urlEncode({
            vs_currency: vsCurrency,
            category_id: categoryId,
            locale,
            page,
            per_page: perPage,
            order,
        });
        return this.getReq(`/coins_lite?${encodedUrl}`);
    }
    /**
     * List all exchanges
     * https://api.coingecko.com/api/v3/exchanges
     */
    getExchanges(page = 1, perPage = 100) {
        const encodedUrl = urlEncode({
            per_page: perPage,
            page,
        });
        return this.getReq(`/exchanges?${encodedUrl}`);
    }
    /**
     * List all supported markets id and name (no pagination required)
     * https://api.coingecko.com/api/v3/exchanges/list
     */
    getExchangesList() {
        return this.getReq(`/exchanges/list`);
    }
    /**
     * Get exchange volume in BTC and tickers
     * https://api.coingecko.com/api/v3/exchanges/binance
     */
    getExchangesId(id, tickers = true) {
        const encodedUrl = urlEncode({
            include_tickers: tickers,
        });
        return this.getReq(`/exchanges/${id}?${encodedUrl}`);
    }
    getExchangesIdTicker(id, coinIds = [], exchangeLogo = true, page = 0, order = TickerSortOrder.TRUST_SCORE_DESC) {
        const encodedUrl = urlEncode({
            coin_ids: coinIds.join(","),
            include_exchange_logo: exchangeLogo,
            page,
            order,
        });
        return this.getReq(`/exchanges/${id}/tickers?${encodedUrl}`);
    }
    /**
     * Get volume_chart data for a given exchange
     * https://api.coingecko.com/api/v3/exchanges/binance/volume_chart?days=1
     */
    getExchangesIdVolumeChart(id, days) {
        return this.getReq(`/exchanges/${id}/volume_chart?days=${days}`);
    }
    /**
     * List all derivative tickers
     * https://api.coingecko.com/api/v3/derivatives
     */
    getDerivatives() {
        return this.getReq(`/derivatives`);
    }
    /**
     * List all derivative exchanges
     * https://api.coingecko.com/api/v3/derivatives/exchanges
     */
    getDerivativesExchanges(order = DerivativesExchangesSortType.OPEN_INTEREST_BTC_DESC) {
        const encodedUrl = urlEncode({ order });
        return this.getReq(`/derivatives/exchanges?${encodedUrl}`);
    }
    /**
     * Show derivative exchange data
     * https://api.coingecko.com/api/v3/derivatives/exchanges?include_tickers=true
     * @param {string} id Derivative Exchange ID
     * @param {DerivativesExchangeTickerType} includeTickers (use DerivativesExchangeTickerType enum) "all" for all tickers, "unexpired" for unexpired tickers and "" to return no tickers
     */
    getDerivativesExchangesId(id, includeTickers = DerivativesExchangeTickerType.NONE) {
        const encodedUrl = includeTickers !== DerivativesExchangeTickerType.NONE
            ? urlEncode({ include_tickers: includeTickers })
            : "";
        return this.getReq(`/derivatives/exchanges/${id}?${encodedUrl}`);
    }
    /**
     * BEAM
     * List all status_updates with data (description, category, created_at, user, user_title and pin)
     * https://api.coingecko.com/api/v3/status_updates
     */
    getStatusUpdates(page, category = BeamFilterCategories.ALL_CATEGORIES, project = BeamFilterProjectType.ALL, perPage = 10) {
        const encodedUrl = urlEncode({
            page,
            category,
            project_type: project,
            per_page: perPage,
        });
        return this.getReq(`/status_updates?${encodedUrl}`);
    }
    getExchangeRates() {
        return this.getReq("/exchange_rates");
    }
    /**
     * List all finance platforms
     * https://api.coingecko.com/api/v3/finance_platforms
     */
    getFinancePlatforms(perPage = 100, page = 1) {
        const encodedUrl = urlEncode({
            per_page: perPage,
            page,
        });
        return this.getReq(`/finance_platforms?${encodedUrl}`);
    }
    /**
     * List all finance products
     * https://api.coingecko.com/api/v3/finance_products
     */
    getFinanceProducts(perPage = 100, page = 1) {
        const encodedUrl = urlEncode({
            per_page: perPage,
            page,
        });
        return this.getReq(`/finance_products?${encodedUrl}`);
    }
    /**
     * Get cryptocurrency global data
     * https://api.coingecko.com/api/v3/global
     */
    getGlobal() {
        return this.getReq("/global");
    }
}

function deprecated() {
    return (_target, propertyKey, _propertyDescriptor) => {
        console.warn("this class is deprecated and will be removed in a future version of the app\n", "@: ", propertyKey);
    };
}

export { APIError, BeamFilterCategories, BeamFilterProjectType, CGError, ChartPeriodControlOption, CoinGeckoAPI, CoinsMarketsSortOrder, DerivativesContractType, DerivativesExchangeTickerType, DerivativesExchangesSortType, PriceChangePercentage, RootAPI, SortOrder, TickerSortOrder, TrustScore, deprecated, handleError, timeoutWrapper, urlEncode };
//# sourceMappingURL=coingecko-api-ts.es5.js.map
